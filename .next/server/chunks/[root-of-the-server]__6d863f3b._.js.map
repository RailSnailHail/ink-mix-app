{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///home/jim/ink-mix-app/src/app/api/mixes/finish/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { PrismaClient, Prisma } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nexport async function GET() {\n  return NextResponse.json(\n    { error: \"Method Not Allowed. Please use POST to finalize a mix.\" },\n    { status: 405 }\n  );\n}\n\nexport async function POST(request: Request) {\n  try {\n    const { mixName, components, swatchHex } = await request.json();\n\n    if (!mixName || !components || components.length === 0 || !swatchHex) {\n      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });\n    }\n\n    const totalGrams = components.reduce((sum, c) => sum + c.grams, 0);\n    if (totalGrams <= 0) {\n      return NextResponse.json({ error: 'Mix has no weight' }, { status: 400 });\n    }\n\n    const result = await prisma.$transaction(async (tx) => {\n      const newRecipe = await tx.recipe.upsert({\n        where: { name: mixName },\n        update: {\n          swatchHex: swatchHex,\n          components: {\n            deleteMany: {},\n            create: components.map(c => ({ inkId: c.inkId, ratio: c.grams / totalGrams })),\n          }\n        },\n        create: {\n          name: mixName,\n          swatchHex: swatchHex,\n          components: {\n            create: components.map(c => ({ inkId: c.inkId, ratio: c.grams / totalGrams })),\n          },\n        },\n      });\n\n      for (const component of components) {\n        await tx.ink.update({\n          where: { id: component.inkId },\n          data: { stockG: { decrement: component.grams } },\n        });\n      }\n      return newRecipe;\n    });\n\n    return NextResponse.json(result, { status: 201 });\n\n  } catch (error) {\n    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {\n      return NextResponse.json({ error: 'A recipe with this name already exists.' }, { status: 409 });\n    }\n    const errorMessage = error instanceof Error ? error.message : 'An unknown server error occurred.';\n    return NextResponse.json({ error: errorMessage }, { status: 500 });\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,SAAS,IAAI,6HAAA,CAAA,eAAY;AAExB,eAAe;IACpB,OAAO,+PAAA,CAAA,eAAY,CAAC,IAAI,CACtB;QAAE,OAAO;IAAyD,GAClE;QAAE,QAAQ;IAAI;AAElB;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE,GAAG,MAAM,QAAQ,IAAI;QAE7D,IAAI,CAAC,WAAW,CAAC,cAAc,WAAW,MAAM,KAAK,KAAK,CAAC,WAAW;YACpE,OAAO,+PAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QAEA,MAAM,aAAa,WAAW,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,EAAE,KAAK,EAAE;QAChE,IAAI,cAAc,GAAG;YACnB,OAAO,+PAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA,MAAM,SAAS,MAAM,OAAO,YAAY,CAAC,OAAO;YAC9C,MAAM,YAAY,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;gBACvC,OAAO;oBAAE,MAAM;gBAAQ;gBACvB,QAAQ;oBACN,WAAW;oBACX,YAAY;wBACV,YAAY,CAAC;wBACb,QAAQ,WAAW,GAAG,CAAC,CAAA,IAAK,CAAC;gCAAE,OAAO,EAAE,KAAK;gCAAE,OAAO,EAAE,KAAK,GAAG;4BAAW,CAAC;oBAC9E;gBACF;gBACA,QAAQ;oBACN,MAAM;oBACN,WAAW;oBACX,YAAY;wBACV,QAAQ,WAAW,GAAG,CAAC,CAAA,IAAK,CAAC;gCAAE,OAAO,EAAE,KAAK;gCAAE,OAAO,EAAE,KAAK,GAAG;4BAAW,CAAC;oBAC9E;gBACF;YACF;YAEA,KAAK,MAAM,aAAa,WAAY;gBAClC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;oBAClB,OAAO;wBAAE,IAAI,UAAU,KAAK;oBAAC;oBAC7B,MAAM;wBAAE,QAAQ;4BAAE,WAAW,UAAU,KAAK;wBAAC;oBAAE;gBACjD;YACF;YACA,OAAO;QACT;QAEA,OAAO,+PAAA,CAAA,eAAY,CAAC,IAAI,CAAC,QAAQ;YAAE,QAAQ;QAAI;IAEjD,EAAE,OAAO,OAAO;QACd,IAAI,iBAAiB,6HAAA,CAAA,SAAM,CAAC,6BAA6B,IAAI,MAAM,IAAI,KAAK,SAAS;YACnF,OAAO,+PAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0C,GAAG;gBAAE,QAAQ;YAAI;QAC/F;QACA,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC9D,OAAO,+PAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAa,GAAG;YAAE,QAAQ;QAAI;IAClE;AACF","debugId":null}}]
}